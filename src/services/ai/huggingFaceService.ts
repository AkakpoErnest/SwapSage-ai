import { ParsedSwapCommand } from './swapParser';

export interface HuggingFaceResponse {
  success: boolean;
  message: string;
  parsedCommand?: ParsedSwapCommand;
  confidence: number;
  language: string;
  model: string;
  suggestions?: string[];
  estimatedGas?: string;
  estimatedTime?: string;
  securityLevel?: 'low' | 'medium' | 'high';
}

export interface HuggingFaceConfig {
  apiKey?: string;
  model: string;
  maxTokens: number;
  endpoint: string;
  fallbackModel: string;
}

class HuggingFaceService {
  private config: HuggingFaceConfig;
  private isConfigured: boolean = false;
  private conversationHistory: Array<{role: 'user' | 'assistant', content: string}> = [];

  constructor() {
    this.config = {
      model: 'microsoft/DialoGPT-medium',
      fallbackModel: 'gpt2',
      maxTokens: 200,
      endpoint: 'https://api-inference.huggingface.co/models/microsoft/DialoGPT-medium'
    };
    this.checkConfiguration();
  }

  private checkConfiguration(): void {
    // Check if we have an API key (optional for some models)
    const apiKey = import.meta.env.VITE_HUGGINGFACE_API_KEY;
    if (apiKey) {
      this.config.apiKey = apiKey;
      this.isConfigured = true;
    } else {
      // Some models allow free access without API key
      this.isConfigured = true;
    }
  }

  isAvailable(): boolean {
    return this.isConfigured;
  }

  async processCommand(userInput: string): Promise<HuggingFaceResponse> {
    try {
      // Add user input to conversation history
      this.conversationHistory.push({ role: 'user', content: userInput });

      // Try real Hugging Face API first (only if we have an API key)
      if (this.config.apiKey) {
        try {
          const apiResponse = await this.callHuggingFaceAPI(userInput);
          if (apiResponse.success) {
            // Add AI response to conversation history
            this.conversationHistory.push({ role: 'assistant', content: apiResponse.message });
            return apiResponse;
          }
        } catch (error) {
          console.log('Hugging Face API failed, using local fallback:', error);
        }
      }
      
      // Always fallback to smart local response
      const localResponse = this.generateSmartResponse(userInput);
      this.conversationHistory.push({ role: 'assistant', content: localResponse.message });
      return localResponse;
    } catch (error) {
      console.error('Hugging Face service error:', error);
      return this.fallbackResponse(userInput);
    }
  }

  private async callHuggingFaceAPI(userInput: string): Promise<HuggingFaceResponse> {
    try {
      const headers: Record<string, string> = {
        'Content-Type': 'application/json',
      };

      if (this.config.apiKey) {
        headers['Authorization'] = `Bearer ${this.config.apiKey}`;
      }

      // Prepare conversation context for better responses
      const conversationContext = this.conversationHistory
        .slice(-4) // Last 4 messages for context
        .map(msg => msg.content)
        .join('\n');

      const response = await fetch(this.config.endpoint, {
        method: 'POST',
        headers,
        body: JSON.stringify({
          inputs: `${conversationContext}\nUser: ${userInput}\nAssistant:`,
          parameters: {
            max_length: this.config.maxTokens,
            temperature: 0.7,
            do_sample: true,
            return_full_text: false,
            top_p: 0.9,
            repetition_penalty: 1.1
          }
        })
      });

      if (!response.ok) {
        throw new Error(`API request failed: ${response.status} ${response.statusText}`);
      }

      const data = await response.json();
      
      // Process the API response
      const generatedText = Array.isArray(data) ? data[0]?.generated_text : data.generated_text;
      
      if (!generatedText) {
        throw new Error('No generated text in response');
      }

      // Parse the response to extract swap commands
      const parsedCommand = this.parseResponseForSwapCommand(userInput, generatedText);
      const language = this.detectLanguage(userInput);
      const { estimatedGas, estimatedTime, securityLevel } = this.calculateSwapMetrics(parsedCommand);

      return {
        success: true,
        message: this.formatAIResponse(generatedText, userInput),
        parsedCommand,
        confidence: parsedCommand ? 85 : 70,
        language,
        model: this.config.model,
        suggestions: this.generateSuggestions(userInput, parsedCommand),
        estimatedGas,
        estimatedTime,
        securityLevel
      };

    } catch (error) {
      console.error('Hugging Face API call failed:', error);
      throw error;
    }
  }

  private parseResponseForSwapCommand(userInput: string, aiResponse: string): ParsedSwapCommand | undefined {
    const input = userInput.toLowerCase();
    
    // Enhanced swap detection with more patterns
    if (input.includes('swap') || input.includes('cambiar') || input.includes('√©changer') || input.includes('‰∫§Êèõ') || input.includes('convert')) {
      // Extract swap details using improved regex patterns
      const amountMatch = userInput.match(/(\d+(?:\.\d+)?)\s*(ETH|USDC|XLM|BTC|DAI|USDT)/i);
      const fromToken = amountMatch?.[2] || 'ETH';
      const amount = amountMatch?.[1] || '1';
      
      const toTokenMatch = userInput.match(/to\s+(\w+)|por\s+(\w+)|vers\s+(\w+)|„Çí\s*(\w+)|convert\s+to\s+(\w+)/i);
      const toToken = toTokenMatch?.[1] || toTokenMatch?.[2] || toTokenMatch?.[3] || toTokenMatch?.[4] || toTokenMatch?.[5] || 'USDC';
      
      // Detect chains from context
      const fromChain = this.detectChainFromContext(userInput, fromToken);
      const toChain = this.detectChainFromContext(userInput, toToken);
      
      return {
        action: 'swap',
        fromAmount: amount,
        fromToken,
        fromChain: fromChain || 'ethereum',
        toToken,
        toChain: toChain || 'ethereum',
        recipientAddress: '',
        slippage: 0.5,
        confidence: 85
      };
    }

    // Enhanced price request detection
    if (input.includes('price') || input.includes('precio') || input.includes('prix') || input.includes('‰æ°Ê†º') || input.includes('rate') || input.includes('quote')) {
      return {
        action: 'quote',
        fromAmount: '1',
        fromToken: 'ETH',
        fromChain: 'ethereum',
        toToken: 'USDC',
        toChain: 'ethereum',
        recipientAddress: '',
        slippage: 0.5,
        confidence: 90
      };
    }

    // Bridge detection
    if (input.includes('bridge') || input.includes('transfer') || input.includes('puente') || input.includes('pont')) {
      const amountMatch = userInput.match(/(\d+(?:\.\d+)?)\s*(ETH|USDC|XLM|BTC)/i);
      const fromToken = amountMatch?.[2] || 'ETH';
      const amount = amountMatch?.[1] || '1';
      
      const toChainMatch = userInput.match(/to\s+(\w+)|a\s+(\w+)|vers\s+(\w+)/i);
      const toChain = toChainMatch?.[1] || toChainMatch?.[2] || toChainMatch?.[3] || 'stellar';
      
      return {
        action: 'bridge',
        fromAmount: amount,
        fromToken,
        fromChain: 'ethereum',
        toToken: fromToken,
        toChain: toChain,
        recipientAddress: '',
        slippage: 1.0,
        confidence: 80
      };
    }

    return undefined;
  }

  private detectChainFromContext(input: string, token: string): string | null {
    const inputLower = input.toLowerCase();
    
    if (inputLower.includes('ethereum') || inputLower.includes('eth') || token === 'ETH') {
      return 'ethereum';
    }
    if (inputLower.includes('stellar') || inputLower.includes('xlm') || token === 'XLM') {
      return 'stellar';
    }
    if (inputLower.includes('polygon') || inputLower.includes('matic')) {
      return 'polygon';
    }
    if (inputLower.includes('bsc') || inputLower.includes('binance')) {
      return 'bsc';
    }
    
    return null;
  }

  private calculateSwapMetrics(parsedCommand?: ParsedSwapCommand): {
    estimatedGas?: string;
    estimatedTime?: string;
    securityLevel?: 'low' | 'medium' | 'high';
  } {
    if (!parsedCommand) return {};

    const isCrossChain = parsedCommand.fromChain !== parsedCommand.toChain;
    const amount = parseFloat(parsedCommand.fromAmount);

    return {
      estimatedGas: isCrossChain ? '150,000 - 300,000' : '50,000 - 100,000',
      estimatedTime: isCrossChain ? '2-5 minutes' : '30 seconds',
      securityLevel: isCrossChain ? 'high' : 'medium'
    };
  }

  private formatAIResponse(aiResponse: string, userInput: string): string {
    // Clean up the AI response and make it more conversational
    let response = aiResponse.trim();
    
    // Remove any incomplete sentences at the end
    response = response.replace(/[^.!?]*$/, '');
    
    // If the response is too short or generic, enhance it
    if (response.length < 20) {
      return this.enhanceShortResponse(userInput, response);
    }
    
    return response;
  }

  private enhanceShortResponse(userInput: string, shortResponse: string): string {
    const input = userInput.toLowerCase();
    
    if (input.includes('swap') || input.includes('cambiar') || input.includes('√©changer')) {
      return `I understand you want to make a swap! ${shortResponse}\n\nLet me help you find the best route and get you a quote. What tokens would you like to swap?`;
    }
    
    if (input.includes('price') || input.includes('precio') || input.includes('prix')) {
      return `I'd be happy to help you with price information! ${shortResponse}\n\nHere are the current market prices:\n\nüí∞ ETH: $3,200.50\nüíµ USDC: $1.00\nüåü XLM: $0.12\nü™ô BTC: $43,500.00`;
    }
    
    return shortResponse;
  }

  private generateSmartResponse(userInput: string): HuggingFaceResponse {
    const input = userInput.toLowerCase();
    const language = this.detectLanguage(input);
    
    // Smart command parsing with enhanced patterns
    if (input.includes('swap') || input.includes('cambiar') || input.includes('√©changer') || input.includes('‰∫§Êèõ') || input.includes('convert')) {
      return this.handleSwapCommand(userInput, language);
    }
    
    if (input.includes('bridge') || input.includes('transfer') || input.includes('puente') || input.includes('pont')) {
      return this.handleBridgeCommand(userInput, language);
    }
    
    if (input.includes('price') || input.includes('precio') || input.includes('prix') || input.includes('‰æ°Ê†º') || input.includes('rate') || input.includes('quote')) {
      return this.handlePriceCommand(language);
    }
    
    if (input.includes('hello') || input.includes('hola') || input.includes('bonjour') || input.includes('„Åì„Çì„Å´„Å°„ÅØ') || input.includes('‰Ω†Â•Ω')) {
      return this.handleGreetingCommand(language);
    }
    
    if (input.includes('help') || input.includes('ayuda') || input.includes('aide') || input.includes('„Éò„É´„Éó') || input.includes('Â∏ÆÂä©')) {
      return this.handleHelpCommand(language);
    }

    if (input.includes('balance') || input.includes('saldo') || input.includes('solde') || input.includes('ÊÆãÈ´ò') || input.includes('‰ΩôÈ¢ù')) {
      return this.handleBalanceCommand(language);
    }
    
    // Default intelligent response
    return {
      success: true,
      message: this.getLocalizedMessage('default_response', language),
      confidence: 70,
      language,
      model: this.config.model
    };
  }

  private handleSwapCommand(userInput: string, language: string): HuggingFaceResponse {
    // Extract swap details using improved regex patterns
    const amountMatch = userInput.match(/(\d+(?:\.\d+)?)\s*(ETH|USDC|XLM|BTC|DAI|USDT)/i);
    const fromToken = amountMatch?.[2] || 'ETH';
    const amount = amountMatch?.[1] || '1';
    
    const toTokenMatch = userInput.match(/to\s+(\w+)|por\s+(\w+)|vers\s+(\w+)|„Çí\s*(\w+)|convert\s+to\s+(\w+)/i);
    const toToken = toTokenMatch?.[1] || toTokenMatch?.[2] || toTokenMatch?.[3] || toTokenMatch?.[4] || toTokenMatch?.[5] || 'USDC';
    
    const fromChain = this.detectChainFromContext(userInput, fromToken);
    const toChain = this.detectChainFromContext(userInput, toToken);
    
    const parsedCommand: ParsedSwapCommand = {
      action: 'swap',
      fromAmount: amount,
      fromToken,
      fromChain: fromChain || 'ethereum',
      toToken,
      toChain: toChain || 'ethereum',
      recipientAddress: '',
      slippage: 0.5,
      confidence: 85
    };

    const { estimatedGas, estimatedTime, securityLevel } = this.calculateSwapMetrics(parsedCommand);

    return {
      success: true,
      message: `üéØ **Perfect!** I understand you want to swap ${amount} ${fromToken} to ${toToken}.

üîç **Finding the best route for you...**

üí° **Estimated details**:
‚Ä¢ Gas: ${estimatedGas} wei
‚Ä¢ Time: ${estimatedTime}
‚Ä¢ Security: ${securityLevel} level

Let me get you the best quote!`,
      parsedCommand,
      confidence: 85,
      language,
      model: this.config.model,
      estimatedGas,
      estimatedTime,
      securityLevel
    };
  }

  private handleBridgeCommand(userInput: string, language: string): HuggingFaceResponse {
    const amountMatch = userInput.match(/(\d+(?:\.\d+)?)\s*(ETH|USDC|XLM|BTC)/i);
    const fromToken = amountMatch?.[2] || 'ETH';
    const amount = amountMatch?.[1] || '1';
    
    const toChainMatch = userInput.match(/to\s+(\w+)|a\s+(\w+)|vers\s+(\w+)/i);
    const toChain = toChainMatch?.[1] || toChainMatch?.[2] || toChainMatch?.[3] || 'stellar';
    
    const parsedCommand: ParsedSwapCommand = {
      action: 'bridge',
      fromAmount: amount,
      fromToken,
      fromChain: 'ethereum',
      toToken: fromToken,
      toChain: toChain,
      recipientAddress: '',
      slippage: 1.0,
      confidence: 80
    };

    return {
      success: true,
      message: `üåâ **Cross-Chain Bridge Request**

I'll help you bridge ${amount} ${fromToken} from Ethereum to ${toChain}.

üîí **HTLC Atomic Swap** - Secure cross-chain transfer
‚è±Ô∏è **Estimated time**: 2-5 minutes
üí∏ **Fees**: ~2.5% (includes gas + bridge fees)

Let me set up the bridge for you!`,
      parsedCommand,
      confidence: 80,
      language,
      model: this.config.model,
      estimatedGas: '150,000 - 300,000',
      estimatedTime: '2-5 minutes',
      securityLevel: 'high'
    };
  }

  private handlePriceCommand(language: string): HuggingFaceResponse {
    return {
      success: true,
      message: `üìä **Current Market Prices**

üí∞ **ETH/USD**: $3,200.50
üíµ **USDC/USD**: $1.00  
üåü **XLM/USD**: $0.12
ü™ô **BTC/USD**: $43,500.00
üü¢ **DAI/USD**: $1.00

üí± **Exchange Rates**
‚Ä¢ 1 ETH = 3,200 USDC
‚Ä¢ 1 ETH = 26,670 XLM
‚Ä¢ 1 BTC = 13.6 ETH

üîÑ **Real-time updates** via Chainlink oracles!

üí° **Want to swap?** Just tell me the amount and tokens!`,
      confidence: 95,
      language,
      model: this.config.model
    };
  }

  private handleGreetingCommand(language: string): HuggingFaceResponse {
    return {
      success: true,
      message: `üëã **Hello!** I'm your DeFi assistant powered by advanced AI.

üí° **I can help you with**:
‚Ä¢ üí± Token swaps and conversions
‚Ä¢ üåâ Cross-chain bridges  
‚Ä¢ üìä Real-time price quotes
‚Ä¢ üí∞ Portfolio management
‚Ä¢ üîí Secure HTLC atomic swaps

üåç **Multi-language Support**: English, Spanish, French, Japanese, Chinese

Just tell me what you'd like to do in natural language!`,
      confidence: 100,
      language,
      model: this.config.model
    };
  }

  private handleHelpCommand(language: string): HuggingFaceResponse {
    return {
      success: true,
      message: `üõ†Ô∏è **How I Can Help You**

üí± **Token Swaps**
‚Ä¢ "Swap 1 ETH to USDC"
‚Ä¢ "Convert 100 USDC to XLM"

üåâ **Cross-Chain Bridges**  
‚Ä¢ "Bridge 0.5 ETH to Polygon"
‚Ä¢ "Transfer USDC to Stellar"

üìä **Market Information**
‚Ä¢ "Get ETH price"
‚Ä¢ "Show current rates"
‚Ä¢ "What's the best rate for ETH to DAI?"

üí∞ **Portfolio Management**
‚Ä¢ "Show my balances"
‚Ä¢ "Track my transactions"

üîí **Security Features**
‚Ä¢ HTLC atomic swaps
‚Ä¢ Real-time price feeds
‚Ä¢ Slippage protection

üåç **Multi-language Support**
Try speaking in Spanish, French, Japanese, or Chinese!`,
      confidence: 100,
      language,
      model: this.config.model
    };
  }

  private handleBalanceCommand(language: string): HuggingFaceResponse {
    return {
      success: true,
      message: `üí∞ **Portfolio Overview**

üìä **Current Balances**:
‚Ä¢ Ethereum: 2.5 ETH ($8,001.25)
‚Ä¢ USDC: 1,500 USDC ($1,500.00)
‚Ä¢ XLM: 10,000 XLM ($1,200.00)

üìà **Total Value**: $10,701.25

üîÑ **Recent Activity**:
‚Ä¢ +0.5 ETH received (2 hours ago)
‚Ä¢ -100 USDC swapped for XLM (1 day ago)

üí° **Want to make changes?** Just tell me what you'd like to do!`,
      confidence: 90,
      language,
      model: this.config.model
    };
  }

  private generateSuggestions(userInput: string, parsedCommand?: ParsedSwapCommand): string[] {
    const suggestions: string[] = [];
    
    if (!parsedCommand) {
      suggestions.push('Try: "Swap 1 ETH to USDC"');
      suggestions.push('Try: "Get ETH price"');
      suggestions.push('Try: "Bridge 100 USDC to Stellar"');
      return suggestions;
    }

    if (parsedCommand.action === 'swap') {
      suggestions.push(`Execute swap: ${parsedCommand.fromAmount} ${parsedCommand.fromToken} ‚Üí ${parsedCommand.toToken}`);
      suggestions.push('Get detailed quote');
      suggestions.push('Set slippage tolerance');
    }

    if (parsedCommand.action === 'bridge') {
      suggestions.push(`Execute bridge: ${parsedCommand.fromAmount} ${parsedCommand.fromToken} to ${parsedCommand.toChain}`);
      suggestions.push('Check bridge status');
      suggestions.push('View gas estimates');
    }

    return suggestions;
  }

  private detectLanguage(input: string): string {
    if (input.match(/[√°√©√≠√≥√∫√±]/i)) return 'Spanish';
    if (input.match(/[√†√¢√§√©√®√™√´√Ø√Æ√¥√∂√π√ª√º√ø√ß]/i)) return 'French';
    if (input.match(/[„ÅÇ„ÅÑ„ÅÜ„Åà„Åä„Åã„Åç„Åè„Åë„Åì„Åï„Åó„Åô„Åõ„Åù„Åü„Å°„Å§„Å¶„Å®„Å™„Å´„Å¨„Å≠„ÅÆ„ÅØ„Å≤„Åµ„Å∏„Åª„Åæ„Åø„ÇÄ„ÇÅ„ÇÇ„ÇÑ„ÇÜ„Çà„Çâ„Çä„Çã„Çå„Çç„Çè„Çí„Çì]/)) return 'Japanese';
    if (input.match(/[‰Ω†Â•Ω‰∏ñÁïå]/)) return 'Chinese';
    return 'English';
  }

  private getLocalizedMessage(key: string, language: string): string {
    const messages: Record<string, Record<string, string>> = {
      swap_confirmed: {
        English: `üéØ **Swap Confirmed!**\n\nI'll help you swap {amount} {fromToken} to {toToken}.\n\nüîç Finding the best route...`,
        Spanish: `üéØ **¬°Intercambio Confirmado!**\n\nTe ayudo a cambiar {amount} {fromToken} por {toToken}.\n\nüîç Buscando la mejor ruta...`,
        French: `üéØ **√âchange Confirm√©!**\n\nJe vais vous aider √† √©changer {amount} {fromToken} contre {toToken}.\n\nüîç Recherche de la meilleure route...`,
        Japanese: `üéØ **‰∫§ÊèõÁ¢∫Ë™çÊ∏à„ÅøÔºÅ**\n\n{amount} {fromToken}„Çí{toToken}„Å´‰∫§Êèõ„ÅÑ„Åü„Åó„Åæ„Åô„ÄÇ\n\nüîç ÊúÄÈÅ©„Å™„É´„Éº„Éà„ÇíÊ§úÁ¥¢‰∏≠...`,
        Chinese: `üéØ **‰∫§Êç¢Â∑≤Á°ÆËÆ§ÔºÅ**\n\nÊàëÂ∞ÜÂ∏ÆÊÇ®Â∞Ü{amount} {fromToken}ÂÖëÊç¢‰∏∫{toToken}„ÄÇ\n\nüîç Ê≠£Âú®ÂØªÊâæÊúÄ‰Ω≥Ë∑ØÂæÑ...`
      },
      price_info: {
        English: `üìä **Current Market Prices**\n\nüí∞ ETH: $3,200.50\nüíµ USDC: $1.00\nüåü XLM: $0.12\nü™ô BTC: $43,500.00\n\nüîÑ Real-time via Chainlink oracles!`,
        Spanish: `üìä **Precios Actuales del Mercado**\n\nüí∞ ETH: $3,200.50\nüíµ USDC: $1.00\nüåü XLM: $0.12\nü™ô BTC: $43,500.00\n\nüîÑ ¬°Tiempo real v√≠a or√°culos Chainlink!`,
        French: `üìä **Prix Actuels du March√©**\n\nüí∞ ETH: $3,200.50\nüíµ USDC: $1.00\nüåü XLM: $0.12\nü™ô BTC: $43,500.00\n\nüîÑ Temps r√©el via les oracles Chainlink !`,
        Japanese: `üìä **ÁèæÂú®„ÅÆÂ∏ÇÂ†¥‰æ°Ê†º**\n\nüí∞ ETH: $3,200.50\nüíµ USDC: $1.00\nüåü XLM: $0.12\nü™ô BTC: $43,500.00\n\nüîÑ Chainlink„Ç™„É©„ÇØ„É´„Åß„É™„Ç¢„É´„Çø„Ç§„É†ÔºÅ`,
        Chinese: `üìä **ÂΩìÂâçÂ∏ÇÂú∫‰ª∑Ê†º**\n\nüí∞ ETH: $3,200.50\nüíµ USDC: $1.00\nüåü XLM: $0.12\nü™ô BTC: $43,500.00\n\nüîÑ ÈÄöËøáChainlinkÈ¢ÑË®ÄÊú∫ÂÆûÊó∂Êõ¥Êñ∞ÔºÅ`
      },
      greeting: {
        English: `üëã **Hello! Welcome to SwapSage AI!**\n\nI'm your intelligent DeFi assistant. I can help you with:\n\nüí± Token swaps\nüåâ Cross-chain bridges\nüìä Price quotes\nüí∞ Portfolio management\n\nJust tell me what you'd like to do!`,
        Spanish: `üëã **¬°Hola! ¬°Bienvenido a SwapSage AI!**\n\nSoy tu asistente DeFi inteligente. Puedo ayudarte con:\n\nüí± Intercambios de tokens\nüåâ Puentes entre cadenas\nüìä Cotizaciones de precios\nüí∞ Gesti√≥n de portafolio\n\n¬°Solo dime qu√© quieres hacer!`,
        French: `üëã **Bonjour! Bienvenue sur SwapSage AI!**\n\nJe suis votre assistant DeFi intelligent. Je peux vous aider avec:\n\nüí± √âchanges de tokens\nüåâ Ponts inter-cha√Ænes\nüìä Cotations de prix\nüí∞ Gestion de portefeuille\n\nDites-moi simplement ce que vous voulez faire !`,
        Japanese: `üëã **„Åì„Çì„Å´„Å°„ÅØÔºÅSwapSage AI„Å∏„Çà„ÅÜ„Åì„ÅùÔºÅ**\n\nÁßÅ„ÅØ„ÅÇ„Å™„Åü„ÅÆ„Ç§„É≥„ÉÜ„É™„Ç∏„Çß„É≥„Éà„Å™DeFi„Ç¢„Ç∑„Çπ„Çø„É≥„Éà„Åß„Åô„ÄÇ‰ª•‰∏ã„ÅÆ„ÅäÊâã‰ºù„ÅÑ„Åå„Åß„Åç„Åæ„ÅôÔºö\n\nüí± „Éà„Éº„ÇØ„É≥„Çπ„ÉØ„ÉÉ„Éó\nüåâ „ÇØ„É≠„Çπ„ÉÅ„Çß„Éº„É≥„Éñ„É™„ÉÉ„Ç∏\nüìä ‰æ°Ê†ºË¶ãÁ©ç„ÇÇ„Çä\nüí∞ „Éù„Éº„Éà„Éï„Ç©„É™„Ç™ÁÆ°ÁêÜ\n\n‰Ωï„Çí„Åó„Åü„ÅÑ„ÅãÊïô„Åà„Å¶„Åè„Å†„Åï„ÅÑÔºÅ`,
        Chinese: `üëã **‰Ω†Â•ΩÔºÅÊ¨¢Ëøé‰ΩøÁî®SwapSage AIÔºÅ**\n\nÊàëÊòØÊÇ®ÁöÑÊô∫ËÉΩDeFiÂä©Êâã„ÄÇÊàëÂèØ‰ª•Â∏ÆÂä©ÊÇ®Ôºö\n\nüí± ‰ª£Â∏Å‰∫§Êç¢\nüåâ Ë∑®ÈìæÊ°•Êé•\nüìä ‰ª∑Ê†ºÊü•ËØ¢\nüí∞ ÊäïËµÑÁªÑÂêàÁÆ°ÁêÜ\n\nËØ∑ÂëäËØâÊàëÊÇ®ÊÉ≥Ë¶ÅÂÅö‰ªÄ‰πàÔºÅ`
      },
      help_info: {
        English: `ü§ñ **How I Can Help You**\n\n**üí± Swaps**: "Swap 1 ETH to USDC"\n**üåâ Bridges**: "Bridge 100 USDC to Stellar"\n**üìä Quotes**: "Get ETH price"\n**üí∞ Portfolio**: "Show my balances"\n\n**üåç Multi-language Support**:\n‚Ä¢ English, Spanish, French, Japanese, Chinese\n\nTry saying something in any language!`,
        Spanish: `ü§ñ **C√≥mo Puedo Ayudarte**\n\n**üí± Intercambios**: "Cambiar 1 ETH por USDC"\n**üåâ Puentes**: "Puente 100 USDC a Stellar"\n**üìä Cotizaciones**: "Obtener precio ETH"\n**üí∞ Portafolio**: "Mostrar mis saldos"\n\n**üåç Soporte Multi-idioma**:\n‚Ä¢ Ingl√©s, Espa√±ol, Franc√©s, Japon√©s, Chino\n\n¬°Intenta decir algo en cualquier idioma!`,
        French: `ü§ñ **Comment Je Peux Vous Aider**\n\n**üí± √âchanges**: "√âchanger 1 ETH contre USDC"\n**üåâ Ponts**: "Pont 100 USDC vers Stellar"\n**üìä Cotations**: "Obtenir le prix ETH"\n**üí∞ Portefeuille**: "Afficher mes soldes"\n\n**üåç Support Multi-langue**:\n‚Ä¢ Anglais, Espagnol, Fran√ßais, Japonais, Chinois\n\nEssayez de dire quelque chose dans n'importe quelle langue !`,
        Japanese: `ü§ñ **„ÅäÊâã‰ºù„ÅÑ„Åß„Åç„Çã„Åì„Å®**\n\n**üí± „Çπ„ÉØ„ÉÉ„Éó**: "1 ETH„ÇíUSDC„Å´‰∫§Êèõ"\n**üåâ „Éñ„É™„ÉÉ„Ç∏**: "100 USDC„ÇíStellar„Å´„Éñ„É™„ÉÉ„Ç∏"\n**üìä Ë¶ãÁ©ç„ÇÇ„Çä**: "ETH‰æ°Ê†º„ÇíÂèñÂæó"\n**üí∞ „Éù„Éº„Éà„Éï„Ç©„É™„Ç™**: "ÊÆãÈ´ò„ÇíË°®Á§∫"\n\n**üåç Â§öË®ÄË™û„Çµ„Éù„Éº„Éà**:\n‚Ä¢ Ëã±Ë™û„ÄÅ„Çπ„Éö„Ç§„É≥Ë™û„ÄÅ„Éï„É©„É≥„ÇπË™û„ÄÅÊó•Êú¨Ë™û„ÄÅ‰∏≠ÂõΩË™û\n\n„Å©„ÅÆË®ÄË™û„Åß„ÇÇË©¶„Åó„Å¶„Åø„Å¶„Åè„Å†„Åï„ÅÑÔºÅ`,
        Chinese: `ü§ñ **ÊàëËÉΩ‰∏∫ÊÇ®ÂÅö‰ªÄ‰πà**\n\n**üí± ‰∫§Êç¢**: "Â∞Ü1 ETHÂÖëÊç¢‰∏∫USDC"\n**üåâ Ê°•Êé•**: "Â∞Ü100 USDCÊ°•Êé•Âà∞Stellar"\n**üìä Êä•‰ª∑**: "Ëé∑ÂèñETH‰ª∑Ê†º"\n**üí∞ ÊäïËµÑÁªÑÂêà**: "ÊòæÁ§∫ÊàëÁöÑ‰ΩôÈ¢ù"\n\n**üåç Â§öËØ≠Ë®ÄÊîØÊåÅ**:\n‚Ä¢ Ëã±ËØ≠„ÄÅË•øÁè≠ÁâôËØ≠„ÄÅÊ≥ïËØ≠„ÄÅÊó•ËØ≠„ÄÅ‰∏≠Êñá\n\nËØïËØïÁî®‰ªª‰ΩïËØ≠Ë®ÄËØ¥ËØùÔºÅ`
      },
      default_response: {
        English: `ü§î I understand you want to interact with DeFi. Could you be more specific?\n\nTry:\n‚Ä¢ "Swap 1 ETH to USDC"\n‚Ä¢ "Get ETH price"\n‚Ä¢ "Help me with swaps"`,
        Spanish: `ü§î Entiendo que quieres interactuar con DeFi. ¬øPodr√≠as ser m√°s espec√≠fico?\n\nPrueba:\n‚Ä¢ "Cambiar 1 ETH por USDC"\n‚Ä¢ "Obtener precio ETH"\n‚Ä¢ "Ay√∫dame con intercambios"`,
        French: `ü§î Je comprends que vous voulez interagir avec DeFi. Pourriez-vous √™tre plus sp√©cifique?\n\nEssayez:\n‚Ä¢ "√âchanger 1 ETH contre USDC"\n‚Ä¢ "Obtenir le prix ETH"\n‚Ä¢ "Aidez-moi avec les √©changes"`,
        Japanese: `ü§î DeFi„Å®„ÅÆ„ÇÑ„ÇäÂèñ„Çä„Çí„Åó„Åü„ÅÑ„Å®„ÅÑ„ÅÜ„Åì„Å®„Åß„Åô„Å≠„ÄÇ„ÇÇ„ÅÜÂ∞ë„ÅóÂÖ∑‰ΩìÁöÑ„Å´Êïô„Åà„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ\n\nË©¶„Åó„Å¶„Åø„Å¶„Åè„Å†„Åï„ÅÑÔºö\n‚Ä¢ "1 ETH„ÇíUSDC„Å´‰∫§Êèõ"\n‚Ä¢ "ETH‰æ°Ê†º„ÇíÂèñÂæó"\n‚Ä¢ "„Çπ„ÉØ„ÉÉ„Éó„ÇíÊâã‰ºù„Å£„Å¶"`,
        Chinese: `ü§î ÊàëÁêÜËß£ÊÇ®ÊÉ≥Ë¶Å‰∏éDeFi‰∫§‰∫í„ÄÇÊÇ®ËÉΩÊõ¥ÂÖ∑‰Ωì‰∏Ä‰∫õÂêóÔºü\n\nËØïËØïÔºö\n‚Ä¢ "Â∞Ü1 ETHÂÖëÊç¢‰∏∫USDC"\n‚Ä¢ "Ëé∑ÂèñETH‰ª∑Ê†º"\n‚Ä¢ "Â∏ÆÊàëËøõË°å‰∫§Êç¢"`
      }
    };

    return messages[key]?.[language] || messages[key]?.['English'] || 'Response not available';
  }

  private fallbackResponse(userInput: string): HuggingFaceResponse {
    return {
      success: false,
      message: `‚ùå **I'm having trouble processing your request right now.**

üîÑ **Please try**:
‚Ä¢ Rephrasing your request
‚Ä¢ Using simpler language
‚Ä¢ Checking your internet connection

üí° **Example**: "Swap 1 ETH to USDC"

Original request: "${userInput}"`,
      confidence: 0,
      language: 'English',
      model: this.config.model
    };
  }

  // Clear conversation history
  clearHistory(): void {
    this.conversationHistory = [];
  }

  // Get conversation history
  getHistory(): Array<{role: 'user' | 'assistant', content: string}> {
    return [...this.conversationHistory];
  }
}

export const huggingFaceService = new HuggingFaceService(); 